<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>极客专业版 3D 魔方 (3x3 - 12x12)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        :root { --primary: #007aff; --bg: #050505; --card: rgba(30, 30, 30, 0.9); }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: -apple-system, system-ui, sans-serif; color: white; }
        
        /* 界面层 */
        #ui-layer { position: absolute; inset: 0; z-index: 10; pointer-events: none; }
        #ui-layer * { pointer-events: auto; }

        /* 主页选择区 */
        #home-screen {
            position: absolute; inset: 0; background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            backdrop-filter: blur(15px); transition: 0.5s;
        }

        .menu { background: var(--card); padding: 40px; border-radius: 24px; text-align: center; border: 1px solid #333; width: 320px; }
        .mode-btn { 
            width: 100%; padding: 15px; margin: 10px 0; border: none; border-radius: 12px;
            font-size: 16px; font-weight: bold; cursor: pointer; transition: 0.3s; color: white;
        }
        .mode-classic { background: #444; }
        .mode-timer { background: #d35400; }
        .mode-assist { background: #27ae60; }
        .mode-btn:hover { transform: translateY(-2px); filter: brightness(1.2); }

        select { width: 100%; padding: 12px; border-radius: 8px; background: #222; color: white; border: 1px solid #444; margin: 15px 0; cursor: pointer; }

        /* HUD 抬头显示 */
        #hud {
            position: absolute; top: 0; width: 100%; padding: 20px;
            display: flex; justify-content: space-between; box-sizing: border-box;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        }
        .stat-item { background: rgba(255,255,255,0.1); padding: 8px 15px; border-radius: 20px; font-variant-numeric: tabular-nums; }

        /* 辅助模式步骤面板 */
        #assist-panel {
            position: absolute; right: 20px; top: 100px; width: 150px;
            background: var(--card); border-radius: 15px; padding: 15px; display: none;
        }
        .step-item { padding: 8px; border-bottom: 1px solid #333; font-size: 14px; cursor: pointer; color: #aaa; }
        .step-item.active { color: #fff; font-weight: bold; background: rgba(255,255,255,0.1); }

        .hidden { display: none !important; }
        #win-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 48px; font-weight: 900; text-shadow: 0 0 20px rgba(0,255,0,0.5);
            pointer-events: none; opacity: 0;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="home-screen">
        <div class="menu">
            <h1 style="margin-bottom: 5px;">RUBIK PRO</h1>
            <p style="color: #888; margin-top: 0;">3D 高阶交互魔方</p>
            
            <label style="display: block; text-align: left; font-size: 12px; color: #666;">选择尺寸</label>
            <select id="size-select">
                <option value="3">3x3x3 (经典)</option>
                <option value="4">4x4x4</option>
                <option value="5">5x5x5</option>
                <option value="8">8x8x8</option>
                <option value="12">12x12x12 (极限性能)</option>
            </select>

            <button class="mode-btn mode-classic" onclick="game.start('classic')">CLASSIC 玩法</button>
            <button class="mode-btn mode-timer" onclick="game.start('timer')">TIMER 计时挑战</button>
            <button class="mode-btn mode-assist" onclick="game.start('assist')">ASSIST 辅助复原</button>
        </div>
    </div>

    <div id="hud" class="hidden">
        <div class="stat-item" id="hud-mode">MODE: CLASSIC</div>
        <div class="stat-item" id="hud-timer">00:00:00</div>
        <div class="stat-item" id="hud-moves">MOVES: 0</div>
        <button onclick="game.quit()" style="background:none; border: 1px solid #555; color: white; border-radius: 15px; padding: 5px 15px; cursor:pointer;">退出</button>
    </div>

    <div id="assist-panel">
        <div style="font-size: 12px; color: #666; margin-bottom: 10px;">复原步骤 (演示)</div>
        <div id="steps-list"></div>
    </div>

    <div id="win-msg">COMPLETED!</div>
</div>

<div id="container"></div>

<script>
/**
 * 极客魔方核心逻辑引擎
 */
const game = {
    // 基础组件
    scene: null, camera: null, renderer: null,
    cubes: [], dimension: 3, 
    group: null, // 旋转组
    
    // 状态
    mode: 'classic',
    isAnimating: false,
    moves: 0,
    time: 0,
    timerInt: null,
    
    // 交互逻辑变量
    raycaster: new THREE.Raycaster(),
    mouse: new THREE.Vector2(),
    isPointerDown: false,
    pointerStart: new THREE.Vector2(),
    intersectedPiece: null, // 被点击的小方块
    intersectedNormal: null, // 被点击的面法向量
    
    init() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(this.renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambient);
        const sun = new THREE.DirectionalLight(0xffffff, 0.4);
        sun.position.set(10, 20, 10);
        this.scene.add(sun);

        this.camera.position.set(10, 10, 15);
        this.camera.lookAt(0,0,0);

        // 事件监听
        window.addEventListener('mousedown', e => this.onDown(e));
        window.addEventListener('mousemove', e => this.onMove(e));
        window.addEventListener('mouseup', e => this.onUp(e));
        window.addEventListener('touchstart', e => this.onDown(e.touches[0]), {passive: false});
        window.addEventListener('touchmove', e => this.onMove(e.touches[0]), {passive: false});
        window.addEventListener('touchend', e => this.onUp(), {passive: false});
        window.addEventListener('resize', () => this.onResize());

        this.render();
    },

    start(mode) {
        this.mode = mode;
        this.dimension = parseInt(document.getElementById('size-select').value);
        this.moves = 0;
        this.time = 0;
        
        document.getElementById('home-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('hud-mode').innerText = `MODE: ${mode.toUpperCase()}`;
        document.getElementById('hud-moves').innerText = `MOVES: 0`;

        this.createCube();
        if(mode === 'timer') this.startTimer();
        if(mode === 'assist') this.setupAssist();
    },

    createCube() {
        if(this.cubes.length) {
            this.cubes.forEach(c => this.scene.remove(c));
            this.cubes = [];
        }

        const n = this.dimension;
        const offset = (n - 1) / 2;
        const geom = new THREE.BoxGeometry(0.95, 0.95, 0.95);
        
        // 经典魔方配色
        const colors = [0xffffff, 0xb71234, 0x0046ad, 0x009b48, 0xff5800, 0xffd500];

        for(let x=0; x<n; x++) {
            for(let y=0; y<n; y++) {
                for(let z=0; z<n; z++) {
                    // 只渲染外层减少计算量 (Step 17 优化)
                    if(x===0 || x===n-1 || y===0 || y === n-1 || z===0 || z===n-1) {
                        const mats = colors.map(c => new THREE.MeshPhongMaterial({ color: c }));
                        const cube = new THREE.Mesh(geom, mats);
                        cube.position.set(x - offset, y - offset, z - offset);
                        cube.userData = { initialPos: cube.position.clone() };
                        this.scene.add(cube);
                        this.cubes.push(cube);
                    }
                }
            }
        }
        
        // 视角根据尺寸自动调整
        const zoom = n * 2.5;
        gsap.to(this.camera.position, { x: zoom, y: zoom, z: zoom, duration: 1 });
    },

    /**
     * 手势交互系统 (Step 4)
     * 核心原理：通过起始点击点和滑动向量与相机平面的投影夹角来判断旋转轴
     */
    onDown(e) {
        this.isPointerDown = true;
        this.pointerStart.set(e.clientX, e.clientY);
        
        this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObjects(this.cubes);
        
        if(intersects.length > 0) {
            this.intersectedPiece = intersects[0].object;
            this.intersectedNormal = intersects[0].face.normal.clone();
            this.intersectedNormal.applyQuaternion(this.intersectedPiece.quaternion);
        } else {
            this.intersectedPiece = null;
        }
    },

    onMove(e) {
        if(!this.isPointerDown || this.isAnimating) return;
        
        const dragX = e.clientX - this.pointerStart.x;
        const dragY = e.clientY - this.pointerStart.y;
        const distance = Math.sqrt(dragX*dragX + dragY*dragY);

        if(distance > 30 && this.intersectedPiece) {
            this.handleSwipe(dragX, dragY);
            this.isPointerDown = false; // 触发一次旋转后重置
        } else if(distance > 5 && !this.intersectedPiece) {
            // 背景滑动：旋转整个视野
            this.scene.rotation.y += dragX * 0.01;
            this.scene.rotation.x += dragY * 0.01;
            this.pointerStart.set(e.clientX, e.clientY);
        }
    },

    onUp() {
        this.isPointerDown = false;
    },

    handleSwipe(dx, dy) {
        const normal = this.intersectedNormal;
        const pos = this.intersectedPiece.position;
        
        // 将屏幕滑动向量转为 3D 空间向量判断
        let moveDir = new THREE.Vector3();
        if(Math.abs(dx) > Math.abs(dy)) {
            // 水平滑动
            moveDir.set(dx > 0 ? 1 : -1, 0, 0);
        } else {
            // 垂直滑动
            moveDir.set(0, dy > 0 ? -1 : 1, 0);
        }

        // 根据点击的面和滑动方向决定旋转轴
        let axis = '';
        let coord = 0;

        if (Math.abs(normal.y) > 0.5) { // 点击顶/底面
            axis = Math.abs(dx) > Math.abs(dy) ? 'z' : 'x';
            coord = axis === 'x' ? pos.x : pos.z;
        } else if (Math.abs(normal.x) > 0.5) { // 点击侧面 X
            axis = Math.abs(dx) > Math.abs(dy) ? 'z' : 'y';
            coord = axis === 'y' ? pos.y : pos.z;
        } else { // 点击侧面 Z
            axis = Math.abs(dx) > Math.abs(dy) ? 'x' : 'y';
            coord = axis === 'y' ? pos.y : pos.x;
        }

        this.rotateLayer(axis, coord, (dx + dy) > 0 ? 1 : -1);
    },

    rotateLayer(axis, coord, dir) {
        if(this.isAnimating) return;
        this.isAnimating = true;
        
        const layerGroup = new THREE.Group();
        const eps = 0.1;
        const targets = this.cubes.filter(c => Math.abs(c.position[axis] - coord) < eps);
        
        targets.forEach(t => layerGroup.add(t));
        this.scene.add(layerGroup);

        const targetRot = { x: 0, y: 0, z: 0 };
        targetRot[axis] = (Math.PI / 2) * dir;

        // 磁吸手感优化 (Step 9)
        gsap.to(layerGroup.rotation, {
            x: targetRot.x, y: targetRot.y, z: targetRot.z,
            duration: 0.4,
            ease: "back.out(1.4)",
            onComplete: () => {
                targets.forEach(t => {
                    const wp = new THREE.Vector3();
                    const wq = new THREE.Quaternion();
                    t.getWorldPosition(wp);
                    t.getWorldQuaternion(wq);
                    
                    this.scene.add(t);
                    t.position.copy(wp);
                    t.quaternion.copy(wq);
                    
                    // 精度修复 (Step 13)
                    t.position.set(Math.round(t.position.x), Math.round(t.position.y), Math.round(t.position.z));
                });
                this.scene.remove(layerGroup);
                this.isAnimating = false;
                this.moves++;
                document.getElementById('hud-moves').innerText = `MOVES: ${this.moves}`;
                this.checkWin();
            }
        });
    },

    /**
     * 辅助模式功能 (Step 7)
     */
    setupAssist() {
        const panel = document.getElementById('assist-panel');
        const list = document.getElementById('steps-list');
        panel.style.display = 'block';
        list.innerHTML = '';
        
        const demoSteps = ["R (右顺时针)", "U (上顺时针)", "L' (左逆时针)", "F2 (前旋转180)", "D (底顺时针)"];
        demoSteps.forEach((s, i) => {
            const div = document.createElement('div');
            div.className = 'step-item';
            div.innerText = `${i+1}. ${s}`;
            div.onclick = () => {
                document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
                div.classList.add('active');
                this.rotateLayer('y', (this.dimension-1)/2, 1); // 模拟动作
                if(i === demoSteps.length - 1) setTimeout(()=>alert("复原完成！"), 600);
            };
            list.appendChild(div);
        });
    },

    /**
     * 工具函数
     */
    startTimer() {
        clearInterval(this.timerInt);
        this.startTime = Date.now();
        this.timerInt = setInterval(() => {
            const diff = Date.now() - this.startTime;
            const ms = Math.floor(diff % 1000 / 10);
            const s = Math.floor(diff / 1000 % 60);
            const m = Math.floor(diff / 60000 % 60);
            document.getElementById('hud-timer').innerText = 
                `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}:${ms.toString().padStart(2,'0')}`;
        }, 30);
    },

    checkWin() {
        // 复原检测简化：如果模式不是辅助且移动次数多
        if(this.moves > 0 && this.mode !== 'assist') {
            // 在实际项目中，这里应遍历所有 cubes 检查 rotation.equals 和 position
        }
    },

    quit() {
        location.reload();
    },

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    },

    render() {
        requestAnimationFrame(() => this.render());
        this.renderer.render(this.scene, this.camera);
    }
};

// 启动
window.onload = () => game.init();
</script>

</body>
</html>

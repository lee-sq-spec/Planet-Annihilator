import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { Rocket, Zap, Target, ThermometerSnowflake, Radiation, ZapOff } from 'lucide-react';

// --- 武器与行星配置 ---
const WEAPONS_CONFIG = [
  { id: 'meteor', name: '动能陨石', icon: <Rocket />, color: 0xffaa00, power: 200, desc: '物理打击，产生巨大撞击坑。' },
  { id: 'laser', name: '重粒子炮', icon: <Zap />, color: 0x00f2ff, power: 20, desc: '持续照射，融化地壳。' },
  { id: 'freeze', name: '寒冬射线', icon: <ThermometerSnowflake />, color: 0x88ffff, power: 15, desc: '冻结地表，产生结晶碎片。' },
  { id: 'nuke', name: '反物质弹', icon: <Radiation />, color: 0xff4400, power: 500, desc: '高能湮灭，地表结构完全破坏。' },
  { id: 'emp', name: '电磁脉冲', icon: <ZapOff />, color: 0xffff00, power: 50, desc: '摧毁护盾，干扰行星反击。' }
];

const PLANETS_CONFIG = [
  { id: 'earth', name: '地球', color: 0x2266ff, hp: 3000, pop: 8.0 },
  { id: 'mars', name: '火星', color: 0xcc4422, hp: 2000, pop: 0.1 },
  { id: 'jupiter', name: '木星', color: 0xffaa66, hp: 10000, pop: 0 }
];

export default function App() {
  const mountRef = useRef(null);
  const [selectedWeapon, setSelectedWeapon] = useState(WEAPONS_CONFIG[0]);
  const [currentPlanet, setCurrentPlanet] = useState(PLANETS_CONFIG[0]);
  const [stats, setStats] = useState({ hp: 3000, maxHp: 3000, pop: 8.0, anger: 0 });
  const [isCountering, setIsCountering] = useState(false);

  // 3D 引用容器
  const sceneRef = useRef({
    scene: null, camera: null, renderer: null, 
    planet: null, projectiles: [], particles: []
  });

  // 1. 初始化 Three.js 场景
  useEffect(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    mountRef.current.appendChild(renderer.domElement);

    // 光照
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(10, 10, 10);
    scene.add(sun);

    sceneRef.current = { ...sceneRef.current, scene, camera, renderer };

    // 动画循环
    const animate = () => {
      requestAnimationFrame(animate);
      if (sceneRef.current.planet) sceneRef.current.planet.rotation.y += 0.001;
      
      // 更新投射物
      sceneRef.current.projectiles.forEach((p, i) => {
        p.mesh.position.lerp(p.target, 0.1);
        if (p.mesh.position.distanceTo(p.target) < 0.2) {
          triggerImpact(p.target, p.weapon);
          scene.remove(p.mesh);
          sceneRef.current.projectiles.splice(i, 1);
        }
      });

      // 更新粒子
      sceneRef.current.particles.forEach((p, i) => {
        p.mesh.position.add(p.vel);
        p.life -= 0.02;
        p.mesh.material.opacity = p.life;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          sceneRef.current.particles.splice(i, 1);
        }
      });

      renderer.render(scene, camera);
    };
    animate();

    return () => {
      renderer.dispose();
      mountRef.current?.removeChild(renderer.domElement);
    };
  }, []);

  // 2. 切换行星
  useEffect(() => {
    const { scene } = sceneRef.current;
    if (!scene) return;

    if (sceneRef.current.planet) scene.remove(sceneRef.current.planet);

    const geo = new THREE.SphereGeometry(8, 64, 64);
    const mat = new THREE.MeshStandardMaterial({ 
      color: currentPlanet.color,
      roughness: 0.8
    });
    const planet = new THREE.Mesh(geo, mat);
    scene.add(planet);
    sceneRef.current.planet = planet;

    setStats({
      hp: currentPlanet.hp,
      maxHp: currentPlanet.hp,
      pop: currentPlanet.pop,
      anger: 0
    });
  }, [currentPlanet]);

  // 3. 攻击逻辑
  const handleFire = (e) => {
    if (e.clientX > window.innerWidth - 300) return;
    
    const { scene, camera, planet } = sceneRef.current;
    const mouse = new THREE.Vector2(
      (e.clientX / window.innerWidth) * 2 - 1,
      -(e.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(planet);

    if (intersects.length > 0) {
      const hitPoint = intersects[0].point;
      const startPos = hitPoint.clone().normalize().multiplyScalar(40);
      
      const mesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshBasicMaterial({ color: selectedWeapon.color })
      );
      mesh.position.copy(startPos);
      scene.add(mesh);
      
      sceneRef.current.projectiles.push({ mesh, target: hitPoint, weapon: selectedWeapon });
    }
  };

  const triggerImpact = (pos, weapon) => {
    // 扣血逻辑
    setStats(prev => {
      const newHp = Math.max(0, prev.hp - weapon.power);
      const newAnger = prev.anger + weapon.power;
      
      if (newAnger > 800) triggerPlanetCounter();
      
      return { ...prev, hp: newHp, anger: newAnger };
    });

    // 产生粒子
    for (let i = 0; i < 10; i++) {
      const p = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 0.2, 0.2),
        new THREE.MeshBasicMaterial({ color: weapon.color, transparent: true })
      );
      p.position.copy(pos);
      const vel = new THREE.Vector3((Math.random()-0.5), (Math.random()-0.5), (Math.random()-0.5));
      sceneRef.current.particles.push({ mesh: p, vel, life: 1.0 });
      sceneRef.current.scene.add(p);
    }
  };

  const triggerPlanetCounter = () => {
    setIsCountering(true);
    setTimeout(() => setIsCountering(false), 2000);
    // 此处可添加向镜头发射物体的逻辑
  };

  return (
    <div className={`game-container ${isCountering ? 'shake' : ''}`} onMouseDown={handleFire}>
      <div ref={mountRef} className="canvas-wrapper" />
      
      {/* 环形 HUD */}
      <div className="hud-overlay">
        <div className="stats-left">
          <p className="label">人口存活</p>
          <h2 className="value">{(stats.pop * (stats.hp / stats.maxHp)).toFixed(2)} B</h2>
        </div>
        <div className="stats-right">
          <p className="label">结构稳定性</p>
          <h2 className="value text-red-500">{Math.ceil((stats.hp / stats.maxHp) * 100)}%</h2>
        </div>
        <div className="planet-info">
          <h1>{currentPlanet.name}</h1>
          <p className={isCountering ? 'text-red-500' : 'text-cyan-400'}>
            {isCountering ? '!! 警告：行星正在反击 !!' : '轨道监测：正常'}
          </p>
        </div>
      </div>

      {/* 武器菜单 */}
      <aside className="weapon-menu">
        <h3>武器系统</h3>
        <div className="grid grid-cols-2 gap-2 mt-4">
          {WEAPONS_CONFIG.map(w => (
            <button 
              key={w.id}
              onClick={() => setSelectedWeapon(w)}
              className={`w-btn ${selectedWeapon.id === w.id ? 'active' : ''}`}
            >
              {w.icon}
              <span className="text-[10px] mt-1">{w.name}</span>
            </button>
          ))}
        </div>
        <div className="mt-6 p-4 bg-black/40 rounded border border-white/10">
          <p className="text-red-500 font-bold uppercase">{selectedWeapon.name}</p>
          <p className="text-xs text-gray-400 mt-2">{selectedWeapon.desc}</p>
        </div>
      </aside>

      {/* 行星选择 */}
      <div className="planet-selector">
        {PLANETS_CONFIG.map(p => (
          <button 
            key={p.id}
            onClick={() => setCurrentPlanet(p)}
            className={`p-btn ${currentPlanet.id === p.id ? 'active' : ''}`}
            style={{ borderColor: `#${p.color.toString(16)}` }}
          />
        ))}
      </div>

      {/* 准星 */}
      <div className="crosshair" />
    </div>
  );
}
